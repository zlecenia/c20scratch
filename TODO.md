Super üî• ‚Äî czyli poszerzamy Tw√≥j IDE o kolejny modu≈Ç:

* Opr√≥cz **OpenAPI ‚Üí bloki API**,
* Opr√≥cz **UI (widoki, menu)**,
* Chcesz jeszcze **automatycznie analizowaƒá skrypty `.py` i `.sh` z folderu `scripts/`** i zamieniaƒá je na bloki, kt√≥re mo≈ºna przeciƒÖgaƒá w edytorze i uruchamiaƒá z parametrami.

To jest bardzo fajny kierunek ‚Üí **IDE low-code z integracjƒÖ API + skrypt√≥w**.

---

## üîë Plan rozbudowy

### 1. **Folder `scripts/`**

* Zawiera pliki `.py` i `.sh`.
* Ka≈ºdy plik reprezentuje funkcjƒô, kt√≥rƒÖ mo≈ºna wywo≈Çaƒá.
* Parametry mo≈ºna wykryƒá:

    * w Pythonie ‚Üí analiza `argparse` lub sygnatur funkcji,
    * w Bash ‚Üí analiza `getopts` lub komentarzy (np. `# param: name type`).

---

### 2. **Automatyczna analiza**

üîπ **Python** (prostym regexem):

* Szuka funkcji `def nazwa(param1, param2="x"):`
* Wydobywa nazwƒô i listƒô parametr√≥w.

üîπ **Bash** (pro≈õciej):

* Szuka linii `# param: nazwaparam typu` albo u≈ºywa `"$1"`, `"$2"`.

Mo≈ºemy to zrealizowaƒá po stronie backendu (np. Node/Python serwer), kt√≥ry:

1. Wczyta folder `scripts/`.
2. Prze≈õle do przeglƒÖdarki JSON:

```json
{
  "scripts": [
    { "name": "process_data.py", "params": ["input_file", "threshold"] },
    { "name": "deploy.sh", "params": ["env", "version"] }
  ]
}
```

---

### 3. **Generowanie blok√≥w Blockly**

Na podstawie JSON dodajemy kategoriƒô `Scripts`.
Dla ka≈ºdego skryptu ‚Üí nowy blok:

* Blok `uruchom process_data.py` z polami `input_file`, `threshold`.
* Blok `uruchom deploy.sh` z polami `env`, `version`.

---

### 4. **Uruchamianie skrypt√≥w**

Tu sƒÖ dwa podej≈õcia:

* **Frontend only (demo)** ‚Üí skrypty nie uruchomiƒÖ siƒô naprawdƒô, tylko generujƒÖ `console.log("Run script ...")`.
* **Backend integration** ‚Üí Blockly generuje `fetch('/run-script', { method:'POST', body: { script:"process_data.py", args:["file.csv", "0.8"] } })`, a backend uruchamia skrypt lokalnie (`subprocess.run`) i zwraca wynik.

---

## üîß Prototyp ‚Äî parsowanie Python + Bash (Node/Python backend)

**server.py (backend)**:

```python
import os, re, json

def parse_python(file_path):
    with open(file_path) as f:
        code = f.read()
    matches = re.findall(r'def\s+(\w+)\s*\((.*?)\):', code)
    functions = []
    for name, args in matches:
        params = [p.strip().split('=')[0] for p in args.split(',') if p.strip()]
        functions.append({"name": name, "params": params})
    return functions

def parse_bash(file_path):
    params = []
    with open(file_path) as f:
        for line in f:
            if line.startswith("# param:"):
                _, spec = line.split(":",1)
                params.append(spec.strip().split()[0])
    return [{"name": os.path.basename(file_path), "params": params}]

def scan_scripts(folder="scripts"):
    scripts = []
    for fname in os.listdir(folder):
        path = os.path.join(folder, fname)
        if fname.endswith(".py"):
            for fn in parse_python(path):
                scripts.append({"script": fname, "func": fn["name"], "params": fn["params"]})
        elif fname.endswith(".sh"):
            for fn in parse_bash(path):
                scripts.append({"script": fname, "func": fn["name"], "params": fn["params"]})
    return scripts

if __name__ == "__main__":
    print(json.dumps(scan_scripts(), indent=2))
```

‚û°Ô∏è To zwr√≥ci np.:

```json
[
  {
    "script": "process_data.py",
    "func": "main",
    "params": ["input_file", "threshold"]
  },
  {
    "script": "deploy.sh",
    "func": "deploy.sh",
    "params": ["env", "version"]
  }
]
```

---

## üîß Integracja w Blockly (frontend)

Po stronie przeglƒÖdarki (np. w Twoim IDE):

```javascript
async function loadScripts() {
  const res = await fetch("/scripts.json"); // backend zwraca JSON z powy≈ºszego parsera
  const scripts = await res.json();
  const scriptsCat = document.createElement("category");
  scriptsCat.setAttribute("name","Scripts");
  scriptsCat.setAttribute("colour","290");

  scripts.forEach(scr => {
    const blockName = `run_${scr.func}_${scr.script.replace(/\W/g,"_")}`;
    const blockEl = document.createElement("block");
    blockEl.setAttribute("type", blockName);
    scriptsCat.appendChild(blockEl);

    // Definicja bloku
    Blockly.Blocks[blockName] = {
      init: function() {
        this.appendDummyInput().appendField("Uruchom " + scr.script + " ‚Üí " + scr.func);
        scr.params.forEach(p=>{
          this.appendValueInput(p).appendField(p);
        });
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(290);
      }
    };

    // Generowanie JS
    Blockly.JavaScript[blockName] = function(block) {
      let args = scr.params.map(p=>{
        let val = Blockly.JavaScript.valueToCode(block,p,Blockly.JavaScript.ORDER_ATOMIC)||'""';
        return val;
      });
      return `fetch("/run-script",{method:"POST",headers:{'Content-Type':'application/json'},
                body:JSON.stringify({script:"${scr.script}",func:"${scr.func}",args:[${args.join(",")}]})})
              .then(r=>r.text()).then(txt=>console.log("Wynik:",txt));\n`;
    };
  });

  document.getElementById("toolbox").appendChild(scriptsCat);
}
```

---

## üöÄ Efekt

* IDE wczytuje `openapi.json` ‚Üí **bloki API**.
* IDE wczytuje `scripts/` ‚Üí **bloki skrypt√≥w Python/Bash**.
* Mo≈ºesz przeciƒÖgnƒÖƒá `uruchom process_data.py` i wstawiƒá parametry,
* Wygenerowany kod JS wysy≈Ça `fetch()` do backendu,
* Backend faktycznie uruchamia skrypt i zwraca wynik.

---

üëå to sk≈Çadamy to w ca≈Ço≈õƒá: **pe≈Çny przep≈Çyw** ‚Üí serwer backend (np. Flask w Pythonie) + frontend Blockly.

Twoje IDE bƒôdzie mog≈Ço:

* **parsowaƒá OpenAPI** i tworzyƒá bloki API,
* **parsowaƒá folder `scripts/`** (Python + Bash) i robiƒá bloki skrypt√≥w,
* generowaƒá kod JS, kt√≥ry wywo≈Ça backend,
* backend odpali skrypt (`subprocess.run`) i zwr√≥ci wynik w JSON.

---

# üîß Backend ‚Äì Flask (`server.py`)

```python
from flask import Flask, request, jsonify, send_from_directory
import subprocess, os, re, json

app = Flask(__name__)

SCRIPTS_FOLDER = "scripts"

# ---- Parsowanie Python ----
def parse_python(file_path):
    with open(file_path) as f:
        code = f.read()
    matches = re.findall(r'def\s+(\w+)\s*\((.*?)\):', code)
    functions = []
    for name, args in matches:
        params = [p.strip().split('=')[0] for p in args.split(',') if p.strip()]
        functions.append({"name": name, "params": params})
    return functions

# ---- Parsowanie Bash ----
def parse_bash(file_path):
    params = []
    with open(file_path) as f:
        for line in f:
            if line.startswith("# param:"):
                _, spec = line.split(":",1)
                params.append(spec.strip().split()[0])
    return [{"name": os.path.basename(file_path), "params": params}]

# ---- Skanowanie katalogu ----
def scan_scripts():
    scripts = []
    for fname in os.listdir(SCRIPTS_FOLDER):
        path = os.path.join(SCRIPTS_FOLDER, fname)
        if fname.endswith(".py"):
            for fn in parse_python(path):
                scripts.append({"script": fname, "func": fn["name"], "params": fn["params"]})
        elif fname.endswith(".sh"):
            for fn in parse_bash(path):
                scripts.append({"script": fname, "func": fn["name"], "params": fn["params"]})
    return scripts

@app.route("/scripts.json")
def scripts_json():
    return jsonify(scan_scripts())

# ---- Uruchamianie skryptu ----
@app.route("/run-script", methods=["POST"])
def run_script():
    data = request.json
    script = data["script"]
    func = data.get("func")
    args = data.get("args", [])

    script_path = os.path.join(SCRIPTS_FOLDER, script)
    if not os.path.exists(script_path):
        return jsonify({"error": "Script not found"}), 404

    try:
        if script.endswith(".py"):
            cmd = ["python3", script_path] + [str(a) for a in args]
        else:
            cmd = ["bash", script_path] + [str(a) for a in args]
        result = subprocess.run(cmd, capture_output=True, text=True)
        return jsonify({"stdout": result.stdout, "stderr": result.stderr, "code": result.returncode})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

# ---- Serwowanie frontendu ----
@app.route("/")
def index():
    return send_from_directory(".", "index.html")

@app.route("/<path:path>")
def static_files(path):
    return send_from_directory(".", path)

if __name__ == "__main__":
    app.run(debug=True)
```

---

# üîß Frontend (`index.html`)

‚û°Ô∏è ten frontend:

* ≈Çaduje bloki API (np. z `openapi.json`),
* ≈Çaduje bloki skrypt√≥w (`/scripts.json` z backendu),
* pozwala przeciƒÖgaƒá i generowaƒá kod,
* wysy≈Ça `fetch('/run-script', ‚Ä¶)` do backendu.

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <script src="https://unpkg.com/blockly/blockly.min.js"></script>
</head>
<body>
  <h2>IDE (API + Skrypty)</h2>
  <div style="display: flex; gap:20px;">
    <div id="blocklyDiv" style="height: 600px; width: 50%;"></div>
    <iframe id="preview" style="height: 600px; width: 50%; border:1px solid #ccc;"></iframe>
  </div>

  <xml id="toolbox" style="display:none">
    <category name="UI" colour="120">
      <block type="add_view"></block>
    </category>
    <category id="apiCategory" name="API" colour="230"></category>
    <category id="scriptsCategory" name="Scripts" colour="290"></category>
  </xml>

  <script>
    const workspace = Blockly.inject('blocklyDiv', { toolbox: document.getElementById('toolbox') });

    // ---- Widok ----
    Blockly.Blocks['add_view'] = {
      init: function() {
        this.appendDummyInput().appendField("Dodaj widok").appendField(new Blockly.FieldTextInput("Widok"), "VIEW");
        this.appendStatementInput("CONTENT").setCheck(null).appendField("zawiera");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(120);
      }
    };
    Blockly.JavaScript['add_view'] = function(block) {
      const name = block.getFieldValue('VIEW');
      const content = Blockly.JavaScript.statementToCode(block, 'CONTENT');
      return `views.push({name:"${name}", html:\`${content}\`});\n`;
    };

    // ---- ≈Åadowanie blok√≥w ze skrypt√≥w ----
    async function loadScripts() {
      const res = await fetch("/scripts.json");
      const scripts = await res.json();
      const scriptsCat = document.getElementById("scriptsCategory");

      scripts.forEach(scr => {
        const blockName = `run_${scr.func}_${scr.script.replace(/\W/g,"_")}`;
        const blockEl = document.createElement("block");
        blockEl.setAttribute("type", blockName);
        scriptsCat.appendChild(blockEl);

        Blockly.Blocks[blockName] = {
          init: function() {
            this.appendDummyInput().appendField("Uruchom " + scr.script + " ‚Üí " + scr.func);
            scr.params.forEach(p=>{
              this.appendValueInput(p).appendField(p);
            });
            this.setPreviousStatement(true, null);
            this.setNextStatement(true, null);
            this.setColour(290);
          }
        };

        Blockly.JavaScript[blockName] = function(block) {
          let args = scr.params.map(p=>{
            let val = Blockly.JavaScript.valueToCode(block,p,Blockly.JavaScript.ORDER_ATOMIC)||'""';
            return val;
          });
          return `fetch("/run-script",{method:"POST",headers:{'Content-Type':'application/json'},
            body:JSON.stringify({script:"${scr.script}",func:"${scr.func}",args:[${args.join(",")}]})})
            .then(r=>r.json()).then(res=>{
              document.body.insertAdjacentHTML("beforeend","<pre>"+JSON.stringify(res,null,2)+"</pre>");
            });\n`;
        };
      });
    }

    // ---- Generowanie wynikowego HTML ----
    function runCode() {
      let code = Blockly.JavaScript.workspaceToCode(workspace);
      let wrapper = `
        let views = [];
        let htmlOutput = "";
        ${code}
        let finalHTML = "";
        views.forEach(v=>{
          finalHTML += '<section id="'+v.name+'">'+v.html+'</section>';
        });
        finalHTML += htmlOutput;
        document.body.innerHTML = finalHTML;
      `;
      document.getElementById('preview').srcdoc = "<script>"+wrapper+"<\/script>";
    }

    setInterval(runCode, 3000);

    // Start
    loadScripts();
  </script>
</body>
</html>
```

---

# üîÑ Przyk≈Çad dzia≈Çania

1. W katalogu `scripts/` masz np.:
   **process\_data.py**

   ```python
   def main(input_file, threshold=0.5):
       print(f"Processing {input_file} with threshold {threshold}")
   if __name__ == "__main__":
       import sys
       main(*sys.argv[1:])
   ```

   **deploy.sh**

   ```bash
   #!/bin/bash
   # param: env string
   # param: version string
   echo "Deploying to $1 version $2"
   ```

2. Backend `/scripts.json` zwr√≥ci:

   ```json
   [
     {"script":"process_data.py","func":"main","params":["input_file","threshold"]},
     {"script":"deploy.sh","func":"deploy.sh","params":["env","version"]}
   ]
   ```

3. W edytorze pojawiƒÖ siƒô bloki:

    * ‚ÄûUruchom process\_data.py ‚Üí main‚Äù z polami `input_file`, `threshold`.
    * ‚ÄûUruchom deploy.sh ‚Üí deploy.sh‚Äù z polami `env`, `version`.

4. Wygenerowany kod odpala backend, kt√≥ry naprawdƒô uruchomi skrypt i zwr√≥ci wynik (stdout/stderr).

---



≈öwietnie üöÄ ‚Äî teraz dorzucimy **dynamiczne formularze w UI**.
Chodzi o to, ≈ºeby u≈ºytkownik, zamiast wpisywaƒá argumenty skrypt√≥w bezpo≈õrednio w bloczkach Blockly, m√≥g≈Ç wygenerowaƒá w widoku **formularz HTML** (np. inputy), a nastƒôpnie po klikniƒôciu przycisku odpaliƒá odpowiedni skrypt z parametrami.

---

## üîë Plan

1. **Rozszerzamy bloki ‚ÄûSkrypty‚Äù**

    * Zamiast tylko `fetch("/run-script")` z parametrami z bloczk√≥w,
    * Blok wygeneruje formularz `<form>` z polami dla parametr√≥w.

2. **Dodajemy przycisk ‚ÄûUruchom‚Äù w formularzu**

    * Po klikniƒôciu JS zbiera warto≈õci input√≥w,
    * Wysy≈Ça `fetch('/run-script', body: {args:[‚Ä¶]})`.

3. **Wynik** (stdout/stderr) pojawia siƒô pod formularzem.

---

## üîß Zmodyfikowany frontend (`index.html` ‚Äì fragment `loadScripts()`)

```javascript
async function loadScripts() {
  const res = await fetch("/scripts.json");
  const scripts = await res.json();
  const scriptsCat = document.getElementById("scriptsCategory");

  scripts.forEach(scr => {
    const blockName = `form_${scr.func}_${scr.script.replace(/\W/g,"_")}`;
    const blockEl = document.createElement("block");
    blockEl.setAttribute("type", blockName);
    scriptsCat.appendChild(blockEl);

    Blockly.Blocks[blockName] = {
      init: function() {
        this.appendDummyInput().appendField("Formularz do " + scr.script + " ‚Üí " + scr.func);
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(290);
      }
    };

    Blockly.JavaScript[blockName] = function() {
      // Generowanie formularza HTML
      let formId = `form_${scr.script}_${scr.func}`;
      let inputs = scr.params.map(p => `<label>${p}: <input name="${p}"></label><br>`).join("");
      let html = `
        htmlOutput += \`
          <form id="${formId}">
            <h3>${scr.script} ‚Üí ${scr.func}</h3>
            ${inputs}
            <button type="button" onclick="run_${formId}()">Uruchom</button>
            <pre id="${formId}_output"></pre>
          </form>\`;
      `;

      // JS do obs≈Çugi formularza
      let jsHandler = `
        window.run_${formId} = function(){
          const form = document.getElementById("${formId}");
          let data = {};
          ${scr.params.map(p => `data["${p}"] = form.querySelector('[name="${p}"]').value;`).join("\n")}
          fetch("/run-script",{method:"POST",headers:{'Content-Type':'application/json'},
            body:JSON.stringify({script:"${scr.script}",func:"${scr.func}",args:Object.values(data)})})
            .then(r=>r.json())
            .then(res=>{
              document.getElementById("${formId}_output").innerText = 
                "stdout:\\n"+res.stdout+"\\n---\\nstderr:\\n"+res.stderr;
            });
        }
      `;
      return html + jsHandler;
    };
  });
}
```

---

## üîÑ Efekt w przeglƒÖdarce

1. Wstawiasz blok ‚ÄûFormularz do process\_data.py ‚Üí main‚Äù do widoku.
2. W podglƒÖdzie (`iframe`) pojawi siƒô:

```html
<form id="form_process_data_py_main">
  <h3>process_data.py ‚Üí main</h3>
  <label>input_file: <input name="input_file"></label><br>
  <label>threshold: <input name="threshold"></label><br>
  <button type="button" onclick="run_form_process_data_py_main()">Uruchom</button>
  <pre id="form_process_data_py_main_output"></pre>
</form>
```

3. U≈ºytkownik wpisuje parametry (np. `data.csv`, `0.8`).
4. Klik ‚ÄûUruchom‚Äù ‚Üí wysy≈Ça request do backendu ‚Üí backend odpala skrypt i zwraca wynik.
5. Wynik (`stdout` / `stderr`) pojawia siƒô w `<pre>` pod formularzem.

---

## üîÆ Rozszerzenia

* Dodanie typ√≥w parametr√≥w (np. `number`, `file upload`) na podstawie analizy kodu.
* Mo≈ºliwo≈õƒá tworzenia **kompletnych widok√≥w aplikacji** (np. strona `Analiza ‚Üí formularz + wynik`).
* Eksport do statycznego projektu (HTML + JSON z definicjƒÖ workflow).


